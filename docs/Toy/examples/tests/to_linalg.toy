# RUN: python -m toy %s --emit=linalg --ir | filecheck %s

# User defined generic function that operates on unknown shaped arguments
def multiply_transpose(a, b) {
  return transpose(a) * transpose(b);
}

def main() {
  var a<2, 3> = [[1, 2, 3], [4, 5, 6]];
  var b<2, 3> = [1, 2, 3, 4, 5, 6];
  var c = multiply_transpose(a, b);
  var d = multiply_transpose(b, a);
  print(d);
}

# CHECK:      builtin.module {
# CHECK-NEXT:   func.func @main() {
# CHECK-NEXT:     %0 = "memref.alloc"() <{"operandSegmentSizes" = array<i32: 0, 0>}> : () -> memref<3x2xf64>
# CHECK-NEXT:     %1 = "memref.alloc"() <{"operandSegmentSizes" = array<i32: 0, 0>}> : () -> memref<3x2xf64>
# CHECK-NEXT:     %2 = "memref.alloc"() <{"operandSegmentSizes" = array<i32: 0, 0>}> : () -> memref<3x2xf64>
# CHECK-NEXT:     %3 = arith.constant 1.000000e+00 : f64
# CHECK-NEXT:     %4 = arith.constant 2.000000e+00 : f64
# CHECK-NEXT:     %5 = arith.constant 3.000000e+00 : f64
# CHECK-NEXT:     %6 = arith.constant 4.000000e+00 : f64
# CHECK-NEXT:     %7 = arith.constant 5.000000e+00 : f64
# CHECK-NEXT:     %8 = arith.constant 6.000000e+00 : f64
# CHECK-NEXT:     %9 = "memref.alloc"() <{"operandSegmentSizes" = array<i32: 0, 0>}> : () -> memref<2x3xf64>
# CHECK-NEXT:     %10 = arith.constant 1.000000e+00 : f64
# CHECK-NEXT:     %11 = arith.constant 2.000000e+00 : f64
# CHECK-NEXT:     %12 = arith.constant 3.000000e+00 : f64
# CHECK-NEXT:     %13 = arith.constant 4.000000e+00 : f64
# CHECK-NEXT:     %14 = arith.constant 5.000000e+00 : f64
# CHECK-NEXT:     %15 = arith.constant 6.000000e+00 : f64
# CHECK-NEXT:     %16 = "memref.alloc"() <{"operandSegmentSizes" = array<i32: 0, 0>}> : () -> memref<2x3xf64>
# CHECK-NEXT:     "affine.store"(%10, %16) {"map" = affine_map<() -> (0, 0)>} : (f64, memref<2x3xf64>) -> ()
# CHECK-NEXT:     "affine.store"(%11, %16) {"map" = affine_map<() -> (0, 1)>} : (f64, memref<2x3xf64>) -> ()
# CHECK-NEXT:     "affine.store"(%12, %16) {"map" = affine_map<() -> (0, 2)>} : (f64, memref<2x3xf64>) -> ()
# CHECK-NEXT:     "affine.store"(%13, %16) {"map" = affine_map<() -> (1, 0)>} : (f64, memref<2x3xf64>) -> ()
# CHECK-NEXT:     "affine.store"(%14, %16) {"map" = affine_map<() -> (1, 1)>} : (f64, memref<2x3xf64>) -> ()
# CHECK-NEXT:     "affine.store"(%15, %16) {"map" = affine_map<() -> (1, 2)>} : (f64, memref<2x3xf64>) -> ()
# CHECK-NEXT:     "affine.store"(%3, %9) {"map" = affine_map<() -> (0, 0)>} : (f64, memref<2x3xf64>) -> ()
# CHECK-NEXT:     "affine.store"(%4, %9) {"map" = affine_map<() -> (0, 1)>} : (f64, memref<2x3xf64>) -> ()
# CHECK-NEXT:     "affine.store"(%5, %9) {"map" = affine_map<() -> (0, 2)>} : (f64, memref<2x3xf64>) -> ()
# CHECK-NEXT:     "affine.store"(%6, %9) {"map" = affine_map<() -> (1, 0)>} : (f64, memref<2x3xf64>) -> ()
# CHECK-NEXT:     "affine.store"(%7, %9) {"map" = affine_map<() -> (1, 1)>} : (f64, memref<2x3xf64>) -> ()
# CHECK-NEXT:     "affine.store"(%8, %9) {"map" = affine_map<() -> (1, 2)>} : (f64, memref<2x3xf64>) -> ()
# CHECK-NEXT:     "linalg.generic"(%9, %2) <{"indexing_maps" = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1, d0)>], "iterator_types" = [#linalg.iterator_type<parallel>, #linalg.iterator_type<parallel>], "operandSegmentSizes" = array<i32: 1, 1>}> ({
# CHECK-NEXT:     ^0(%17 : f64):
# CHECK-NEXT:       linalg.yield %17 : f64
# CHECK-NEXT:     }) : (memref<2x3xf64>, memref<3x2xf64>) -> ()
# CHECK-NEXT:     "linalg.generic"(%16, %1) <{"indexing_maps" = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d1, d0)>], "iterator_types" = [#linalg.iterator_type<parallel>, #linalg.iterator_type<parallel>], "operandSegmentSizes" = array<i32: 1, 1>}> ({
# CHECK-NEXT:     ^1(%18 : f64):
# CHECK-NEXT:       linalg.yield %18 : f64
# CHECK-NEXT:     }) : (memref<2x3xf64>, memref<3x2xf64>) -> ()
# CHECK-NEXT:     "linalg.generic"(%2, %1, %0) <{"indexing_maps" = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], "iterator_types" = [#linalg.iterator_type<parallel>, #linalg.iterator_type<parallel>, #linalg.iterator_type<parallel>], "operandSegmentSizes" = array<i32: 2, 1>}> ({
# CHECK-NEXT:     ^2(%19 : f64, %20 : f64):
# CHECK-NEXT:       %21 = arith.mulf %19, %20 : f64
# CHECK-NEXT:       linalg.yield %21 : f64
# CHECK-NEXT:     }) : (memref<3x2xf64>, memref<3x2xf64>, memref<3x2xf64>) -> ()
# CHECK-NEXT:     printf.print_format "{}", %0 : memref<3x2xf64>
# CHECK-NEXT:     "memref.dealloc"(%16) : (memref<2x3xf64>) -> ()
# CHECK-NEXT:     "memref.dealloc"(%9) : (memref<2x3xf64>) -> ()
# CHECK-NEXT:     "memref.dealloc"(%2) : (memref<3x2xf64>) -> ()
# CHECK-NEXT:     "memref.dealloc"(%1) : (memref<3x2xf64>) -> ()
# CHECK-NEXT:     "memref.dealloc"(%0) : (memref<3x2xf64>) -> ()
# CHECK-NEXT:     func.return
# CHECK-NEXT:   }
# CHECK-NEXT: }

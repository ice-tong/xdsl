from collections.abc import Callable
from io import StringIO

# pyright: ignore[reportMissingTypeStubs, reportGeneralTypeIssues]
from pyclip import copy as pyclip_copy
from textual import events, on
from textual.app import App, ComposeResult
from textual.containers import Horizontal, ScrollableContainer, Vertical
from textual.widgets import Button, Label, SelectionList, TextArea

from xdsl.dialects import builtin
from xdsl.ir import MLContext
from xdsl.parser import Parser
from xdsl.passes import ModulePass, PipelinePass
from xdsl.printer import Printer
from xdsl.tools.command_line_tool import get_all_dialects, get_all_passes

"""
This app allows you to paste xDSL IR into the Input TextArea, select a pass (or multiple passes) to be applied on the input IR
and subsequently the IR generated by the application of the selected pass(es) is displayed in the Output TextArea. The selected
passes are displayed in the top right "Selecred passes/query" box. The "Condense" button filters the pass selection list to
display passes that change the IR, or require arguments to be executed (and thus "may" change the IR). The "Uncondense" button
returns the selection list to contain all the passes. The "Clear Passes" Button removes the application of the selected passes.
The "Copy Query" Button allows the user to copy the selected passes/query that they have so far selected (i.e. copy the top right
box).

This app is still under construction.
"""
pyclip_copy: Callable[[str], None] = pyclip_copy


# Function that takes the input IR, the list of passes to be applied, and applies the passes to the IR.
# Returns the module (after pass is applied).
def transform_input(
    input_text: str, passes: list[type[ModulePass]]
) -> builtin.ModuleOp:
    ctx = MLContext(True)
    for dialect in get_all_dialects():
        ctx.load_dialect(dialect)

    parser = Parser(ctx, input_text)
    module = parser.parse_module()

    pipeline = PipelinePass([p() for p in passes])
    pipeline.apply(ctx, module)

    return module


# Used to check if a pass has had an effect on the IR (i.e. has changed the IR)
def check_if_pass_changes_IR(
    input: builtin.ModuleOp, ctx: MLContext, one_pass: ModulePass
) -> bool:
    cloned_module = input.clone()
    cloned_ctx = ctx.clone()
    one_pass.apply(cloned_ctx, cloned_module)
    return not input.is_structurally_equivalent(cloned_module)


# Used to prevent users from being able to change/alter the Output TextArea
class OutputTextArea(TextArea):
    async def _on_key(self, event: events.Key) -> None:
        event.prevent_default()


# Class buildling the Experimental Interactive Compilation App.
class InputApp(App[None]):
    CSS_PATH = "app.tcss"
    text: str

    # Initialization function
    def __init__(self, text: str | None = None):
        if text is None:
            text = ""
        self.text = text
        super().__init__()

    # Creates the required widgets, events, etc.
    def compose(self) -> ComposeResult:
        # Get the list of xDSL passes, add them to an array in "Selection" format (so it can be added to a Selection List)
        # and sort the list in alphabetical order.
        list_of_passes = get_all_passes()
        selections = [(value.name, value) for value in list_of_passes]
        selections.sort()
        my_selection_list: SelectionList[type[ModulePass]] = SelectionList(
            *selections, id="passes_selection_list"
        )

        # Horizontal(SelectedList, Label) - Container to align the layout of the pass options + displaying selected passes
        with Horizontal(id="selected_passes_and_list_horizontal"):
            # Label displaying the passes that have been selected
            with Horizontal(id="selection_list_and_button"):
                yield my_selection_list  # SelectedList with the pass options
                with Vertical(id="buttons_and_selection_list"):
                    with Horizontal(id="clear_selection_list"):
                        yield Button("Clear Passes", id="clear_selection_list_button")
                    with Horizontal(id="condense_pass_list"):
                        yield Button("Condense", id="condense_pass_list_button")
                    with Horizontal(id="undo_condense"):
                        yield Button("Undo Condense", id="undo_condense_button")
                    with Horizontal(id="copy_query"):
                        yield Button("Copy Query", id="copy_query_button")
            yield ScrollableContainer(
                Label("", id="selected_passes_label"), id="selected_passes"
            )
        with Horizontal(id="input_output"):
            with Vertical(id="input_and_button"):
                yield TextArea(self.text, id="input")  # TextArea with the Input IR
                with Horizontal(
                    id="clear_input"
                ):  # Horizontal(Button) used to Clear Input TextArea
                    yield Button("Clear Input", id="clear_input_button")
            # Container(OutputTextArea) to show Output IR (a TextArea class that has been extended)
            with Vertical(id="output_container"):
                yield OutputTextArea("No output", id="output")
                with Horizontal(
                    id="copy_output"
                ):  # Horizontal(Button) used to Copy Output TextArea
                    yield Button("Copy Output", id="copy_output_button")

    @property
    def module_passes_selection_list(self) -> SelectionList[type[ModulePass]]:
        return self.query_one(SelectionList[type[ModulePass]])

    # Returns the list of user selected passes
    def selected_module_passes(self) -> list[type[ModulePass]]:
        return self.module_passes_selection_list.selected

    # When the SelectionList (pass options) changes (i.e. a pass was selected or deselected), update the label to show
    # the query, and then call the execute() function, which applies the selected passes to the input and displays the output
    @on(SelectionList.SelectedChanged)
    def update_selected_view(self) -> None:
        new_passes = "\n" + (", " + "\n").join(
            p.name for p in self.selected_module_passes()
        )
        new_label = f"xdsl-opt -p {new_passes}"
        self.query_one(Label).update(new_label)
        self.execute()

    # On App Mount, add titles + execute()
    def on_mount(self) -> None:
        self.query_one("#input_and_button").border_title = "Input xDSL IR"
        self.query_one(
            SelectionList
        ).border_title = "Choose a pass or multiple passes to be applied."
        self.query_one("#output_container").border_title = "Output xDSL IR"
        self.query_one("#selected_passes").border_title = "Selected passes/query"
        self.execute()

    # Function that gathers input IR and selected list of passes, calls transform_input() - which returns the module. The output
    # stream is then printed and loaded to the output TextArea. (Applies the selected passes to the input IR and displays the output)
    def execute(self, input: TextArea | None = None):
        if input is None:
            input = self.query_one("#input", TextArea)

        passes = self.selected_module_passes()

        input_text = input.text
        try:
            module = transform_input(input_text, passes)

            output_stream = StringIO()
            Printer(output_stream).print(module)
            output_text = output_stream.getvalue()
        except Exception as e:
            output_text = str(e)

        output = self.query_one("#output", TextArea)
        output.load_text(output_text)

    # When the input TextArea changes, call exectue function
    @on(TextArea.Changed, "#input")
    def on_input_changed(self, event: TextArea.Changed):
        self.execute(event.text_area)

    # When the "Clear Input" button is pressed, the input IR TextArea is cleared
    @on(Button.Pressed, "#clear_input_button")
    def on_clear_input_button_pressed(self, event: Button.Pressed) -> None:
        input = self.query_one("#input", TextArea)
        input.clear()

    # When the "Copy Output" button is pressed, the output IR TextArea is copied
    @on(Button.Pressed, "#copy_output_button")
    def on_copy_output_button_pressed(self, event: Button.Pressed) -> None:
        output = self.query_one("#output", TextArea)
        pyclip_copy(output.text)

    # When the "Clear Passes" button is preseed, the SelectionList is cleared
    @on(Button.Pressed, "#clear_selection_list_button")
    def on_clear_selection_list_button_pressed(self, event: Button.Pressed) -> None:
        passes_selection_list = self.query_one("#passes_selection_list", SelectionList)
        selected_passes = self.query_one("#selected_passes_label", Label)
        passes_selection_list.deselect_all()
        self.execute()
        selected_passes.update("")

    # When the "Copy Query" button is preseed, the selected passes/query is copied
    @on(Button.Pressed, "#copy_query_button")
    def on_copy_query_button_pressed(self, event: Button.Pressed) -> None:
        selected_passes = "\n" + (", " + "\n").join(
            p.name for p in self.selected_module_passes()
        )
        query = f"xdsl-opt -p {selected_passes}"
        pyclip_copy(query)

    # When the "Condense" button is preseed, the SelectionList is filtered to contain only passes that structurally change the IR
    @on(Button.Pressed, "#condense_pass_list_button")
    def on_condense_button_pressed(self, event: Button.Pressed) -> None:
        input = self.query_one("#input", TextArea).text
        if not input:
            return

        passes = get_all_passes()

        try:
            # todo, add parse method that doesnt apply any passes
            module = transform_input(input, [])
        except Exception:
            return

        ctx = MLContext(True)
        for dialect in get_all_dialects():
            ctx.load_dialect(dialect)

        self.module_passes_selection_list.clear_options()
        condense_selections = []

        for p in passes:
            try:
                if check_if_pass_changes_IR(module, ctx, p()):
                    item = (p.name, p)
                    condense_selections.append(item)
            except Exception:
                item = (p.name, p)
                # todo color #todo, add option to add arguments + execute
                condense_selections.append(item)

        condense_selections.sort()
        self.module_passes_selection_list.add_options(condense_selections)

    # When the "Undo Condense" button is preseed, the SelectionList is returned to its original state (i.e. containing all the passes)
    @on(Button.Pressed, "#undo_condense_button")
    def on_undo_condense_button_pressed(self, event: Button.Pressed) -> None:
        self.module_passes_selection_list.clear_options()
        passes = get_all_passes()
        selections = [(value.name, value) for value in passes]
        selections.sort()
        self.module_passes_selection_list.add_options(selections)


if __name__ == "__main__":
    path = "tests/filecheck/backend/riscv/canonicalize.mlir"
    with open(path) as f:
        text = f.read()
    app = InputApp(text)
    app.run()
